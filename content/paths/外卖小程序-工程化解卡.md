---
title: 外卖小程序：工程化解卡（不拖主线）
draft: false
stage: budding
---

# 外卖小程序工程化解卡（时间盒：不拖 P0/P1）

这份文档的定位是：让你的外卖小程序从“对接就炸”变成“可控可迭代”，同时严格限制它的侵占：**每周 2–3 小时维护**，不能抢 P0/P1 主线。

## 1）你卡死的根因（不是“不会写代码”）

典型根因是：

- 接口契约不清（字段/状态/错误码随意变）
- 角色/权限/多租户模型不稳定
- 前后端联调缺少“可验证中间层”（mock/用例/合同测试）
- 主要靠 AI 写 → 没有边界与验收 → 功能越多越不可控

## 2）先用 2 小时把“系统骨架”定死（Domain 分层）

把系统拆成 4 个域（域 = 后端代码模块边界）：

1. 商户域：merchant/store/product
2. 订单域：order + order_items + 状态机
3. 骑手域：rider + dispatch
4. 管理域：admin/audit/config/ops

硬规则：

- 所有端（用户/商户/骑手/管理员 Web）**只能调 API**，禁止直接读写数据库集合/表
- 所有状态变更统一由后端/云函数处理（做权限校验、状态校验、写审计日志）

## 3）用“订单状态机”解决一半对接问题（必须）

把订单状态做成枚举，并写清楚允许的流转（示例）：

- CREATED（已创建未支付）
- PAID（已支付待接单）
- ACCEPTED（商户已接单）
- PREPARING（制作中）
- READY（待骑手取餐）
- PICKED_UP（骑手已取）
- DELIVERED（已送达）
- CANCELED（取消）
- REFUNDED（退款）

每次状态变更都要产出审计记录（谁/何时/从哪到哪/原因）。

## 4）接口契约优先（Contract First）+ Mock（你现在最缺）

按顺序做三件事：

1. 写 `api-spec.md`（哪怕不是 OpenAPI，也先列清接口清单）
2. 每个接口写一份“请求/响应示例 JSON”（含错误响应）
3. 做 Mock（最简单：后端/云函数返回固定假数据），让前端先跑通页面与流程

建议优先列出管理员端最关键的 10–20 个接口：

- 商户审核、门店管理、商品管理、订单查询、退款、骑手管理、运营配置

## 5）用例驱动联调（别再靠“目测”）

建立 `tests/` 或 `postman/`：

- 每个接口至少 1 个成功用例 + 1 个失败用例（权限/参数/状态非法）
- 用例过了才算完成；AI 写代码也必须对着用例跑

## 6）上线策略：只做 MVP，别试图一次“全功能”

最小闭环建议：

- 管理员：商户入驻/门店配置/菜品管理/订单监控（先别做复杂结算）
- 商户：接单/出餐状态
- 骑手：接单/送达
- 用户：下单（支付暂时不稳可先“到店付/线下付”跑通运营）

> 这个项目对你投后端很加分：多租户、RBAC、订单状态机、异步通知、可靠性，都是面试官爱问的。  
> 但它只能是 L3/L2：时间盒、可维护、可验收，不许拖主线。
