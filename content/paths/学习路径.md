---
title: 端到云（IoT平台）作为主工程主线 + 机器人/边缘作为作品集升级方向
draft: false
stage: budding
---

# 学习路径（技能地图版）

这页是“技能地图 + 技术选型 + 取舍原则”，目标是让你知道：

- 该学什么、学到什么程度算“够用”
- P0→P1 为什么这样设计、能投哪些岗位
- 哪些内容现在**禁止碰**（避免越学越乱）

如果你现在觉得信息太多、脑子转不过来：

- 先回到 [[paths/index|路径索引]]，按“只打开 1 个文件”的规则重置
- 日常只用 [[执行路径]] 推进本周 Gate；这页只在“我该学到什么程度才够用？”时翻一眼

> 想看“按周/月/学期 Gate 的长期执行计划”：看 [[执行路径]]。  
> 想把协议/Topic/API/DB 钉死成“单一真相”：看 [[P0_SPEC_v1]]。

## 0）阅读导航（把文档做成可维护系统）

- 主线执行：[[执行路径]]
- 待确认问题（决定路线走向的选择）：[[待确认问题]]
- P0 单一真相规格：[[P0_SPEC_v1]]
- 实时规则（时序/并发/阻塞）：[[实时规则]]
- 日志规范（链路可观测与定位）：[[日志规范]]
- 错误码与故障字典（现象→定位→修复）：[[错误码与故障字典]]
- 测试体系（单测→合同→E2E→故障注入）：[[测试体系]]
- DoD 清单（版本交付最低线）：[[DoD清单]]
- 新机器复现清单（交付可信度）：[[新机器10分钟复现清单]]
- CI 最小闭环（把质量锁住）：[[CI最小闭环]]
- 安全最小线（不做 TLS 也先守住底线）：[[安全最小线]]
- 作品集材料包（简历要点/追问清单/英文讲稿）：[[作品集材料包]]
- P1 小车规格（安全/坐标系/闭环要求）：[[P1_SPEC_v0]]
- STM32 调试排障（CMSIS-DAP + OpenOCD）：[[STM32-CMSIS-DAP-OpenOCD-调试排障]]
- 外卖小程序（时间盒维护，不拖主线）：[[外卖小程序-工程化解卡]]
- 路径A（可选升级：ESP32 自联网）：[[路径A-STM32+ESP32-可选升级]]

## 1）总体策略（真实建议：兼顾兴趣与实习成功率）

你想做“机器人/边缘计算”，但当前最大短板是**工程落地能力**。最稳的策略不是三选一，而是：

> 用一个 IoT 端到云闭环（P0）把工程能力打穿，再用小车/机器人（P1）复用同一套底座升级。

这条路的收益是“覆盖面 + 可迁移”：

- 国内：嵌入式、IoT 平台/边缘网关、IoT 后端、机器人系统/平台岗都能投
- 海外：可复现 repo + Docker Compose + 英文 README + demo 视频，非常加分

## 2）项目主线（P0→P1：一年内尽量不改架构）

### P0（端到云闭环底座）

闭环定义：上行能入库可查询，下行能执行有 ACK，可观测可复现。

项目页入口：[[projects/p0-edge-sense/index|P0 项目页（Edge Sense）]]（建议把你的周报/复盘证据都往这个项目页体系里沉淀）。

默认链路（路径B）：

```text
STM32 ─ 串口协议 ─> PC/树莓派网关(Python) ─ MQTT ─ 后端(FastAPI) ─ DB(Postgres) ─ API/曲线
```

P0 的协议/Topic/API/DB **全部以 [[P0_SPEC_v1]] 为准**（避免三端漂移）。

### P1（小车/机器人升级）

P1 的关键不是“功能更多”，而是补齐机器人系统必备的非功能要求：

- 安全：急停、命令超时刹车、限速、低电压保护
- 时序/坐标系：单位、方向、时间戳一致性

项目页入口：[[projects/smart-car/index|P1 项目页（智能小车）]]。

规格入口：[[P1_SPEC_v0]]。

## 3）学习路线（技能地图：学到“能做工程”为止）

### A. 编程与基础（必须补齐，否则所有方向都卡）

目标：能写“可维护、可测试、可排障”的工程代码。

- C：指针/内存/结构体/模块边界/Makefile 或 CMake；会用调试器（GDB/LLDB）
- 数据结构（面试够用）：数组/链表/栈队列/哈希/堆；会分析复杂度
- C++（后移）：RAII/STL/智能指针（够工程用即可）
- Python：够写网关脚本/后端/测试脚本（不追花活）

### B. 计算机通识（面试能讲 + 项目真用）

- OS：进程/线程/锁/内存/IO（用“面试卡片”驱动）
- 网络：TCP/UDP、HTTP、DNS、TLS（概念到能结合项目讲）
- Linux：权限、systemd、日志、性能排查（网关/部署必用）
- Git：分支、PR、rebase、tag/Release、最小 CI 思维

### C. IoT 端到云核心（你的护城河）

- 端侧：UART/I2C/SPI/Timer/PWM + 状态机 + 错误码 + 日志
- 网关：串口协议解析、MQTT pub/sub、重连、可观测
- 云端：MQTT 消费入库、查询 API、命令状态机、可复现部署（Docker Compose）
- 可靠性：超时/重试/幂等、故障注入、runbook（见 [[测试体系]]）

### D. 加分方向（门槛进入，不抢主线）

- 安全（最小线）：token/HMAC、重放保护（先不做 TLS 全套）
- 边缘 AI：部署与性能（等 P0/P1 稳定后再上）
- ROS2/导航：你想碰可以，但要按门槛进入
  - 门槛：先把 P0 做到 v1.0 稳定（长跑 + 故障注入过关），再系统学 ROS2
  - 节奏：先仿真（ROS2 基础/TF/teleop/Nav2）→ 再把 P1 控制/遥测做成 ROS2 node → 最后再上真车导航硬件

## 4）“可投递标准”（大三暑期实习前你要交付的证据）

### 4.1 CS 基础（面试能讲）

- OS：进程/线程、同步互斥、内存、文件 IO、死锁
- 计网：TCP/UDP、HTTP、DNS、TLS 基本流程（能结合你的 P0）
- Linux + Git：能在 Linux 上编译调试、看日志、抓包、用 Git 规范协作

### 4.2 代码能力（能干活）

- C：模块化、错误处理、调试、协议与状态机
- Python：网关/脚本/最小后端能力（能落地即可）
- C++：后移（大三上逐步补）

### 4.3 作品集（能演示、能复现、能追问）

- P0：端到云闭环（含 ACK/幂等/可观测/可复现部署）
- P1：小车升级（云控+遥测闭环，含安全约束）
- 材料包：英文 README、demo 视频、追问清单（见 [[作品集材料包]]）

## 5）硬件采购建议（≤ 2000 RMB，按优先级）

- 传感器（P0 优先）：`BME280`（温湿压三合一，最适合做曲线展示）
- 逻辑分析仪（强烈建议）：抓 UART/I2C，排错效率提升巨大
- Raspberry Pi 5：建议在“大二下 Linux 部署月”买；买来也先当网关，不要让装系统阻塞主线
- P1 小车硬件（暑假前买）：底盘 + 带编码器电机 + TB6612/DRV8833 + 电池与稳压

## 6）跑偏预警（现在别碰）

- TLS/证书体系、OTA、边缘 AI：统一进 Backlog
- ROS2/导航：不是禁止，而是必须满足门槛再进入（看 [[待确认问题]] 与 [[执行路径]]）
- 前端美化：先能看曲线/能下发命令即可
- “为了学而学”的课程刷完：只看当周 Gate 需要的章节





---

## 你未来可能走的 3 条岗位方向（先知道终点，学习才不迷路）

嵌入式岗位大体分三类，你不需要现在就“押宝”，但要知道各自的核心能力：

### A. MCU/单片机固件工程师（STM32/ESP32/国产 MCU）

- 核心：**C语言、外设驱动、时钟/中断/定时器/DMA、调试能力、RTOS（常见）**
    
- 项目：传感器采集、控制（电机/舵机/功率器件）、通信（UART/SPI/I2C/CAN）、低功耗
    

### B. 嵌入式 Linux 应用工程师（板子上跑 Linux）

- 核心：**Linux基础、C/C++系统编程、多进程/多线程、网络、交叉编译、工程化**
    
- 项目：守护进程、网络服务、串口网关、媒体/采集程序、与驱动/硬件交互
    

### C. BSP/驱动工程师（更硬核、回报也更硬核）

- 核心：**内核/驱动模型、设备树、GPIO/I2C/SPI、内核调试、启动链路**
    
- 项目：写驱动、改设备树、移植外设、定位时序/中断/内存等问题
    

> 建议你的路线：**先把 A 做扎实（更容易做出成果）→ 再补 B（实习岗位多）→ 如果你兴趣强再冲 C。**

---

## 总路线图（你只需要按这个走，不用同时“全学”）

**基础（C + 工具 + 数据结构）**  
→ **MCU 外设与调试（做项目）**  
→ **FreeRTOS（让项目变“像工程”）**  
→ **嵌入式 Linux 用户态（Buildroot/交叉编译/系统编程）**  
→ **Linux 驱动/设备树（选修但很加分）**  
→ **用 2~3 个作品集项目拿实习/校招**

---

## 2 年半时间轴规划（按“大二下 → 大三 → 大四”）

下面按“学期阶段”给你明确的**目标、产出、必须会的点**。你照着打钩就行。

---

# 阶段 0：先把“环境与工具”建好（1~2 周）

这是最容易被忽略、但最影响效率的部分。

你要做到：

- 能在 Linux 上写 C：`gcc / make / gdb`
    
- 会用 Git：`clone / commit / branch / merge / tag`
    
- 会最基本的调试：断点、单步、查看变量、查看栈
    

**最低配置建议**

- 电脑：装 Ubuntu 双系统或用 WSL2（能用 Ubuntu 最好）
    
- IDE：VSCode（配 C/C++ 插件）
    
- 工具：`gcc`、`make`、`gdb`、`cmake`（后面用）、`git`
    

**产出**

- 建一个 GitHub 仓库：`c_basics`，把练习代码都放进去，每个小练习写 README（1~2 行也行）
    

---

# 阶段 1：C 语言“从会写”到“能写对”（大二下前半段，4~8 周）

你现在的瓶颈几乎一定不是“语法”，而是：

- 指针/数组/字符串的真实含义
    
- 内存模型（栈/堆/静态区）
    
- 模块化（.h/.c 组织）
    
- 写代码不崩、不乱、可调
    

### 你书单怎么用（建议顺序微调）

- ✅ 入门快速过：**《C语言程序设计（谭浩强）》**  
    目标：能写函数、循环、数组、基本 I/O。  
    **不要在这本书上死磕**，很多题意义不大。
    
- ✅ 主线重点：**《C 和指针》**  
    这是你从“会一点 C”变成“能做嵌入式”的关键书。
    
- ✅ 进阶扫盲：**《C 专家编程》**  
    用来纠正常见误区（编译、链接、声明定义、未定义行为等）。
    
- ✅ 工程习惯：**《高质量 C 编程》**  
    当作“代码规范 + 可靠性清单”，不需要从头背。
    

### 这一阶段你必须掌握的“面试/实战关键点清单”

- 指针与数组：`char *p` vs `char a[]`，指针算术
    
- 字符串：`\0`、`strlen/sizeof` 区别
    
- 结构体对齐、大小端、位运算（嵌入式常用）
    
- `static/extern/volatile/const`（尤其 volatile）
    
- 编译链接基本概念：`.c -> .o -> 可执行`，头文件只放声明
    

### 这一阶段的最小项目（强烈建议做）

做一个“可运行的小工具”就行，不要太大：

1. **命令行通讯录/学生管理系统（文件存储）**
    

- 功能：增删改查 + 保存到文件
    
- 你会练到：结构体、指针、文件 I/O、模块化、错误处理
    

**产出要求（很重要）**

- README 写清：如何编译运行、功能截图（终端输出也算）
    
- 代码至少拆成：`main.c` + `xxx.c/xxx.h`
    

---

# 阶段 2：数据结构与算法（贯穿大二下~大三上，每天一点）

嵌入式不需要你刷成算法竞赛，但**实习/校招笔试**常考基础题。

### 书单建议

- ✅ 《大话数据结构》：用来建立直觉（1~2 周扫完）
    
- 《算法导论》：非常厚、非常慢  
    建议：**用它查你真想深入的章节**（排序/堆/哈希/图），不要把“看完算法导论”当目标。
    

### 更实际的目标（面向实习）

你用 C 自己实现并写单元测试（哪怕是简单 assert）：

- 单链表/双链表
    
- 栈/队列
    
- 环形队列（嵌入式串口缓冲超级常用）
    
- 二叉树遍历（理解递归/栈）
    
- 哈希表（理解冲突处理）
    
- 排序：快排/归并/堆排至少会讲原理
    

### 刷题策略（不痛苦、但有效）

- 每周：**3 道 easy + 1 道 medium**
    
- 优先题型：数组、链表、栈队列、二分、哈希、双指针、简单 DP
    
- 每道题都要求自己总结一句：**“这题用的是什么模型/套路？”**
    

---

# 阶段 3：MCU 裸机与外设（大三上主线，8~12 周）

这是你作品集的“第一桶金”，也是你建立自信最快的阶段。

### 推荐平台（选一个就行）

- **STM32（强烈推荐）**：生态广、外设全、资料多、实习岗位也多
    
- ESP32：偏物联网/WiFi，应用多，但底层外设/实时性也要学
    
- 51/AVR：能学，但对找实习的“展示价值”不如 STM32
    

### 你要掌握的“外设主线”（按顺序）

1. GPIO（输入输出/上拉下拉）
    
2. 定时器（定时中断、PWM）
    
3. 串口 UART（收发、中断方式）
    
4. SPI / I2C（驱动一个传感器/屏幕）
    
5. ADC（采样电压/传感器）
    
6. DMA（理解为什么它能提升效率）
    
7. 中断优先级、临界区（和后面 RTOS 对接）
    

### 必做项目（选 2 个）

项目要“像产品功能”，别只做 LED：

1. **多传感器数据采集 + 串口协议输出**
    

- 例如：温湿度 + 光照/加速度
    
- 上位机用串口助手/你后面用 Qt 做 GUI
    
- 加分点：自己定义帧格式（帧头+长度+校验）
    

2. **PID 控制小项目（哪怕是模拟）**
    

- PWM 控制电机/舵机（或用 LED 亮度模拟控制量）
    
- 加分点：说明采样周期、控制周期、抗抖/滤波
    

**调试能力要求（嵌入式核心竞争力）**

- 会用 ST-Link/J-Link 单步、看寄存器、看内存
    
- 会用逻辑分析仪/示波器更好（没有也能先用串口打印 + GPIO 翻转测时序）
    

---

# 阶段 4：FreeRTOS（大三上后半/寒假，4~6 周）

你做完裸机项目后，FreeRTOS 会让你从“能跑”变成“工程结构清晰”。

要掌握：

- 任务、优先级、时间片
    
- 队列、信号量、互斥锁
    
- 任务间通信设计（谁生产、谁消费）
    
- ISR 与任务的交互（FromISR 系列 API）
    
- 堆内存策略（heap_4 等概念不用死背，但要知道怎么选）
    

**FreeRTOS 项目建议（强烈加分）**

- “传感器采集任务” + “通信任务” + “显示/日志任务”
    
- 加一个“看门狗/异常自恢复”机制（体现工程思维）
    

---

# 阶段 5：嵌入式 Linux 用户态（大三下主线，8~12 周）

这部分是实习岗位非常常见的要求。

### 书单怎么用（给你更省力的读法）

- ✅ 《鸟哥的 Linux 私房菜》：把常用命令、权限、进程管理打牢（选章节学）
    
- 《Linux 高性能服务器编程》：偏网络服务器/高并发  
    对嵌入式 Linux 应用也有用（socket/epoll/线程池），但别一上来啃太深。
    
- 《Linux 内核设计与实现》：用于理解 OS 原理（进程、内存、调度）
    
- 《Linux 设备驱动》那两本：内容可能偏旧，但**概念仍然值钱**  
    真写驱动时要结合你当前内核版本的官方文档/源码（这是行业常态）。
    

### 这一阶段必须会的硬技能

- 交叉编译：知道 `arm-linux-gnueabihf-gcc` 这类工具链是什么
    
- Makefile 基础、CMake 入门（很多项目会用）
    
- 系统编程：文件 I/O、select/poll/epoll、线程、互斥
    
- Linux 下与硬件交互：`/dev/ttyS*`、`i2c-dev`、`spidev`、`sysfs` / `procfs` 基本认识
    

### 项目（让你“像嵌入式 Linux 工程师”）

1. **树莓派/香橙派等板子上做：串口网关/数据采集守护进程**
    

- 采集 MCU 通过串口发来的数据
    
- Linux 端解析后写文件或发 MQTT/HTTP（你选一个）
    
- 重点：程序健壮性（断线重连、日志、配置文件）
    

2. **Buildroot 做一个最小系统（强加分）**
    

- 你不需要精通 Yocto（太重），但 Buildroot 做出来很展示能力
    
- 产出：你自己生成的 rootfs + 你写的应用随系统启动运行
    

---

# 阶段 6：Linux 驱动/设备树（大三暑假~大四上，选修但很顶）

如果你未来想走 BSP/驱动，这阶段是关键；哪怕你做一点点，也很加分。

建议学习顺序：

1. 字符设备驱动（open/read/write/ioctl）
    
2. platform driver 基本框架
    
3. GPIO 子系统（申请/配置/中断）
    
4. I2C/SPI 驱动写一个简单外设（哪怕是 EEPROM/传感器）
    
5. 设备树：会写节点、匹配 compatible、理解 probe 流程
    

**最小可展示驱动项目**

- 写一个 GPIO 驱动：通过 `/dev/xxx` 控制一个引脚翻转、读取按键
    
- README 里写清：设备树怎么配、怎么 insmod、怎么测试
    

---

## 你列的 C++ / Qt 应该怎么放（不会拖累主线）

嵌入式岗位“纯 C”也很多，但 C++ 是加分项。**关键是不要让 C++ 抢走你 MCU/Linux 的主线时间。**

### 建议定位

- C++：学到能写**清晰的现代 C++（C++11 起）**，懂 RAII、STL、基本 OOP
    
- Qt：当作“做上位机工具”的武器
    

### 最推荐的 Qt 项目（实习展示非常好）

- **串口调试助手（Qt GUI）**
    
    - 显示传感器曲线/日志
        
    - 支持发送命令（设置采样率、阈值等）
        
    - 这会让你的 MCU 项目立刻“像产品”，展示效果爆炸
        

---

## 作品集项目怎么做才“能拿到实习”

你最终最好有 **2~3 个能讲清楚的项目**，比 10 个半成品强得多。

### 推荐你凑的作品集组合（非常实用）

1. **STM32 裸机 + 外设综合项目**（硬件能力证明）
    
2. **FreeRTOS 多任务采集项目**（工程能力证明）
    
3. **Linux 端守护进程/网关 +（可选）Buildroot**（岗位匹配证明）
    
4. （加分）**一个简单驱动/设备树项目**（区分度证明）
    
5. （加分）**Qt 上位机工具**（展示与工程闭环）
    

### 每个项目必须具备的“简历友好”内容

- README：项目目标、硬件连接图、功能演示、编译运行方式
    
- 关键技术点：比如“DMA+环形缓冲解决串口丢包”“队列解耦任务”
    
- 遇到的 bug 和定位过程（你能讲出来，面试官很吃这一套）
    

---

## 每周学习节奏模板（照着执行就不会乱）

给你一个“稳态节奏”，你可以按自己课业调整：

- **每周 5 天**：每天 1~1.5 小时（学习/写代码）
    
- **周末**：一次 3~4 小时（项目整合/硬件联调）
    
- 每周必须产出：
    
    1. 一个知识点总结（200 字也行）
        
    2. 一个可运行的代码提交（GitHub）
        
    3. 一次硬件验证（串口日志/示波器波形/现象记录）
        

> 你会发现：**嵌入式的成长 = “可验证的产出”堆出来的**，不是“看完某本书”堆出来的。

---

## 面试/实习准备（提前半年开始就很稳）

当你准备投实习时，你至少要能比较顺畅地回答：

### C 语言常问点

- 指针/数组、内存泄漏、野指针
    
- `volatile` 为什么重要（寄存器/中断共享变量）
    
- 结构体对齐、大小端
    
- static/extern 的含义与使用场景
    

### OS / Linux 常问点

- 进程 vs 线程、互斥锁/信号量区别
    
- 死锁四条件、怎么避免
    
- select/poll/epoll 区别（会其中一个也可以）
    
- 常用命令：定位问题（ps/top/dmesg/journalctl）
    

### MCU/硬件常问点

- 中断流程、优先级、临界区
    
- 定时器/PWM、UART/SPI/I2C 的基本时序
    
- 你如何定位“程序卡死/跑飞/偶现 bug”
    

---

## 你现在最该做的 3 件事（从今天就能开始）

1. **C 主线切到《C 和指针》**，每天一小节 + 写小练习
    
2. 选定一个 MCU 平台（建议 STM32），开始做外设小项目
    
3. 建立“作品集仓库”，坚持每周有可运行产出（哪怕很小）
    

---

如果你愿意，我也可以在你这套路线基础上，给你做一个更“执行型”的东西：

- 按你一周可投入时间（比如 8 小时/12 小时/20 小时）拆成**每周任务清单**
    
- 并且把每个阶段的项目拆成“第 1 周做到什么、第 2 周做到什么”的里程碑，让你照着做就能滚动前进。
    

但即使不补充信息，你也可以先按上面阶段 0~2 开始推进：**先把 C+工具链+一个小项目做出来**，你会明显感觉自己不是“弱”，而是过去缺少“可执行路径”。