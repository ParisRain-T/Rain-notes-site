---
title: 安全最小线（不做 TLS 也能先把底线守住）
draft: false
stage: budding
---

# 安全最小线（P0/P1 的“最低防线”）

你现在的目标是把工程能力打穿，不需要一上来就啃完 TLS/证书体系。  
但你仍然需要一条“最低安全线”，否则系统容易出现：

- 误触发/乱发命令导致设备失控（P1 小车尤其危险）
- 重放命令导致重复执行（QoS1 下更常见）
- 设备/后端被随便连上（演示时翻车）

> 这页是“工程底线”，不是完整安全方案。真正上生产要做 TLS、证书、密钥管理与完整威胁建模。

## 1）威胁模型（你先假设这 3 件事会发生）

1. 网络里有人能发 MQTT 消息（哪怕只是同局域网）
2. QoS1 会带来重复投递（重复 cmd 必然发生）
3. 设备侧最危险：一条错误命令可能造成物理风险（电机暴冲、过热、损坏）

## 2）P0 的最小安全线（建议作为 v1.1 Backlog）

### 2.1 Broker 不裸奔（最基本）

- 不要把 MQTT broker 暴露到公网
- 至少启用用户名/密码（演示阶段也要做）
- Topic 权限按 `device_id` 收敛（每个设备只允许 publish/subscribe 自己的 topic）

### 2.2 命令的“真实性”（不靠 TLS 的方案）

最小方案：**命令携带 token / 签名**，设备验证通过才执行。

建议字段（概念）：

- `cmd_id`（幂等键，见 [[P0_SPEC_v1]]）
- `ts_ms`（命令生成时间）
- `expires_ms`（过期时间窗口，例如 5s/30s）
- `sig`（签名：HMAC(cmd_id + payload + ts_ms + expires_ms)）

设备侧规则：

- 超时：超过 `expires_ms` 直接拒绝并回 ACK（带错误码）
- 重放：已执行过的 `cmd_id` 不重复执行（幂等）
- 失败可观测：拒绝必须回 ACK（status=ERROR + err_code）

> 你不需要在 MCU 上做复杂加密库；HMAC（或更简单的 token 校验）就能先把“乱发命令”挡住。

### 2.3 危险命令要“二次确认”（P1 必做）

对可能造成物理风险的命令（速度、转向、电机 PWM）：

- 必须有**限幅**（最大 PWM/最大速度）
- 必须有**超时刹车**（一段时间没新命令就停）
- 必须有**急停**（见 [[P1_SPEC_v0]]）

## 3）把安全写进 DoD（否则你会永远“下次再说”）

建议把“安全最小线”写进 P0 v1.1 / P1 v1.0 的 DoD：

- Broker 有认证；最小权限可用（按设备隔离 topic）
- 命令有过期与重放保护（cmd_id + 时间窗）
- 危险命令有限幅 + 超时刹车 + 急停
- 所有拒绝都可观测（日志 + ACK + DB 可查）

## 4）常见误区（提前避坑）

- “本地演示不用安全”：演示现场最容易翻车（连错 broker/同网段别人发消息）
- “QoS1 就可靠”：QoS1 是至少一次，**会重复**，必须用幂等兜底
- “先把车跑起来再补安全”：P1 里这会导致危险，安全必须前置为 Gate
