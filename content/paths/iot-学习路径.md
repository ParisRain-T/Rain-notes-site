---
title: 端到云（IoT平台）作为主工程主线 + 机器人/边缘作为作品集升级方向
draft: false
stage: budding
---
### A. 编程与基础（必须补齐，否则所有方向都卡）

**C（你现在的起点）→ C++（工程化）→ Python（工具与云端）**

到大三实习前，你至少要做到：

- C：指针/内存/结构体/函数指针/Makefile，能用 gdb/LLDB 调试
    
- 数据结构：数组/链表/栈队列/哈希/堆/树/图（会写 + 会分析复杂度）
    
- C++：掌握基本语法 + RAII + STL + 智能指针（够做工程，不追模板元编程）
    
- Python：能写后端/脚本/数据处理（不要求花哨，要求能落地）
    

### B. 计算机通识（大厂非常看重，尤其海外）

- 操作系统：进程/线程/锁/内存/IO
    
- 计算机网络：TCP/UDP、HTTP、DNS、TLS基本概念
    
- Linux：文件系统、权限、网络命令、systemd、日志、性能排查
    
- Git：分支、PR、rebase、release、tag、CI 基础
    

### C. IoT 端到云核心（你主线的“护城河”）

端侧：

- MCU/RTOS：任务调度、中断、定时器、串口/I2C/SPI、驱动抽象
    
- 通信：BLE/WiFi（或 LoRa/NB-IoT 看你资源）、协议（MQTT/CoAP）
    
- 工程化：日志、错误码、状态机、掉线重连、低功耗、OTA（至少实现一种）
    

云侧：

- MQTT Broker（Mosquitto/EMQX）使用与鉴权
    
- 设备管理：注册、密钥、心跳、在线状态、数据上报
    
- 存储：PostgreSQL（业务）+ 时序库（InfluxDB/Timescale可选）
    
- 部署：Docker + 简单CI（GitHub Actions）+ 基础监控（Prometheus/Grafana 可选）
    

### D. 加分方向（别当主线，但可以让你“更像大厂”）

- 边缘 AI：模型推理部署（ONNX / TFLite / OpenVINO / TensorRT 选其一），重点是**部署与性能**
    
- 安全：TLS、证书、密钥管理、固件签名、基本威胁模型（IoT 安全非常对口）

### 学期 1：大二下（或你接下来这学期）

**目标：把“只会一点C”变成“能做工程的小开发”，并做出第一个端到云闭环项目（哪怕小）**

#### 学什么（优先级顺序）

1. C 语言工程化（2-4周）
    

- Makefile/CMake 二选一（建议先 Makefile）
    
- 指针、内存、结构体、模块化设计、错误处理
    
- 调试：gdb/LLDB（Mac上 LLDB 很常用）
    

2. 数据结构与算法入门（贯穿整个学期）
    

- 每周固定：**5~8题**（不是越多越好，是要总结模板）
    
- 必会：数组/链表/栈队列/哈希/堆/二叉树/图BFSDFS/二分/排序
    

3. Linux + Git 基础（1-2周打底，后面在项目里用）
    

- ssh、文件权限、网络排查命令、进程/端口
    
- Git 分支、PR、commit 规范
    

4. 计算机网络基础（2-3周）
    

- TCP/UDP、HTTP请求响应、DNS、TLS概念
    
- 目标：能解释“为什么 IoT 要 MQTT，怎么保证安全连接”
    

#### 学到什么程度（可验证）

- 能自己写一个**模块化C项目**：多文件、Makefile、带日志与错误码
    
- 能用调试器定位内存越界/空指针
    
- DS：能手写哈希表/队列/堆（至少 2 个写熟）
    

#### 本学期项目（必须做）

**项目 P0：IoT 传感器数据上报系统（最小闭环）**

- 端侧（选一个硬件平台）：
    
    - ESP32（WiFi方便）或 STM32 + WiFi模块
        
    - 采集传感器（温湿度/光照/IMU随便）
        
    - MQTT 上报（JSON 或 protobuf，先 JSON）
        
- 云侧：
    
    - MQTT Broker（本地 Docker 起 Mosquitto/EMQX）
        
    - 后端：Python FastAPI（或 Node/Go，看你喜好）
        
    - 存储：PostgreSQL 或 SQLite（先跑通）
        
    - 可视化：最简单先做网页/命令行，再考虑 Grafana
        
- 关键加分点（至少做一个）：
    
    - 掉线重连 + 心跳
        
    - 鉴权（用户名密码/Token）
        
    - 设备在线状态机
        

#### 作品集产出（你要在 GitHub/博客上留下什么）

- GitHub：
    
    - `iot-sensor-firmware/`
        
    - `iot-cloud-backend/`
        
    - `docker-compose.yml` 一键启动
        
- 博客：
    
    - 3篇：①MQTT入门与实践 ②端侧状态机设计 ③Docker部署与端云联调


### 暑假 1：大二暑假（你冲大三实习的“加速带”）

**目标：把 P0 打磨成能展示的作品 + 开始面试准备**

- 算法：每周 12~20 题，重点在：
    
    - 双指针、滑窗、二分、DFS/BFS、堆、并查集（看目标岗位）
        
- 计算机基础：OS/网络各补一轮（不用学术化，学“面试问法”）
    
- 项目打磨：
    
    - 加 README（架构图、演示动图、部署步骤）
        
    - 做一个 3~5 分钟 Demo 视频
        
    - 写“项目复盘”：踩坑、取舍、性能、下一步
        

---

### 学期 2：大三上

**目标：确定“投递主战位”（嵌入式/云端/边缘），做一个更硬核的项目：小车或机械臂 + 端云协同**

#### 你要做的选择（我先按“嵌入式主战位”给默认方案）

##### 学什么

1. C++ 工程化（4-6周）
    

- RAII、智能指针、STL容器、类设计、接口抽象
    
- 多线程基础（std::thread/锁）了解即可（够面试）
    

2. RTOS 或 Linux 端侧（选其一为主）
    

- 如果你走 MCU：FreeRTOS（任务/队列/互斥/中断）
    
- 如果你走 Linux 边缘：进程/线程/Socket 编程基础 + epoll 概念
    

3. 通信与协议进阶（贯穿）
    

- MQTT QoS、retain、topic设计
    
- TLS 基础与证书（会用即可）
    

#### 本学期项目（建议做这个）

**项目 P1：智能小车（端-边-云）**

- 端侧：MCU 控电机/编码器/IMU；实现 PID 控制、里程计
    
- 边缘：树莓派/工控机（没有就先用电脑）跑 ROS2（或先不ROS2，用自写进程）
    
- 云侧：沿用 P0 的平台，加“设备控制指令下发”
    
- 必做功能：
    
    - 云端下发控制指令 → 车端执行（带 ACK）
        
    - 数据上报：速度/电量/状态
        
    - 远程日志/故障码
        
- 加分：
    
    - Web Dashboard（哪怕简单）
        
    - OTA（先做模拟OTA：下载配置/参数热更新）
        

#### 学到什么程度（可验证）

- 能讲清楚：你系统的架构、通信协议、异常处理、性能瓶颈
    
- 能用逻辑分析/日志把一个“偶发掉线/抖动”定位出来（工程感）


### 学期 3：大三下（实习招聘/面试期）

**目标：简历能投、面试能聊、项目能演示，拿到实习**

#### 主任务（优先级）

1. 简历与投递（贯穿）
    

- 简历只放 2~3 个硬项目（P0 + P1 + 可选P2）
    
- 每个项目要能用 STAR 写出“你的贡献与结果”，不是“我做了XX”
    

2. 面试准备（稳定推进）
    

- 算法：保持手感（每周 8~15 题）
    
- OS/网络：把常见问题整理成自己的“面试卡片”
    
- IoT专项：MQTT、TLS、设备管理、掉线重连、状态机、OTA流程
    

3. 项目 P2（可选，但非常加分）  
    **机械臂项目 or 小车升级版（更偏系统/控制/视觉）**
    

- 如果机械臂：
    
    - 舵机/步进电机控制
        
    - 运动学基础（至少正运动学）
        
    - 上位机控制 + 端云日志
        
- 如果继续小车：
    
    - 加视觉（边缘AI推理，例如目标识别/循迹）
        
    - 做“端云协同推理”：边缘推理结果上报云端分析

### 暑假 2：大三暑假（理想状态：在实习）

**目标：把实习成果转化为“可写进简历的影响力”**

- 每周做一次周报复盘（写在 Obsidian，脱敏后可博客）
    
- 主动争取一个“可以闭环”的任务（哪怕小功能）
    
- 学会写工程文档、写可读的 PR
    

---

### 学期 4：大四上（秋招/海外申请窗口）

**目标：定岗、补短板、冲 offer**

- 如果走国内大厂：系统设计/工程化能力要补（日志、监控、稳定性、性能）
    
- 如果走海外：英语表达 + CS基础 + 项目讲述深度更重要
    
    - 技术英语：能把项目从“背景-设计-权衡-结果-下一步”讲清楚
        
    - 继续刷题，但更重“解释能力”
        

---


## 要达到的“实习可投递标准

到大三投暑期实习前，你要能交付这三样东西：

### 1）CS基础（面试能讲）

- OS：进程/线程、同步互斥、内存管理、文件IO、死锁、上下文切换（会讲 + 会举例）
    
- 计网：TCP/UDP、三次握手四次挥手、HTTP、DNS、TLS大概流程（会讲 + 能结合你的项目）
    
- Linux + Git：能在 Linux 上编译调试、看日志、抓包、用 Git 规范协作
    

### 2）代码能力（能干活）

- C：指针/内存/模块化/Makefile/CMake/调试（LLDB/GDB）
    
- C++：至少能写工程（RAII、智能指针、STL，能写清晰可维护的代码）
    
- Python 或 Go：能写一个后端服务（REST API + 消息消费 + DB）
    

### 3）作品集（能演示的项目）

- **P0：STM32→MQTT→云端存储→可视化**（最小闭环，但要工程化）
    
- **P1：智能小车 或 机械臂（带端云协同）**（更硬核、更像“研发实习”）
    
- 你的外卖小程序：作为“真实业务项目加分”，但**不能把你主线拖死**
    

---


# 0）现在 ～ 寒假结束：打底 + 先做一个“小闭环”

**目标：把“学过”变成“能用”，并做出 P0 的雏形**

### 学什么

1. **C 工程化（必做）**
    

- 多文件组织、头文件边界
    
- 错误码/日志（你写固件必须有）
    
- Makefile（先会用再谈高级）
    
- 调试：断点、观察变量、内存问题定位
    

2. **STM32 必会外设（配合你课程）**
    

- GPIO、EXTI中断
    
- UART（收发 + 环形缓冲）
    
- TIM/PWM（为后面电机准备）
    
- I2C/SPI（接传感器用）
    

3. **Linux + Git 最小可用**
    

- 会用终端、ssh、grep、tail、lsof、netstat/ss
    
- Git：分支、PR、rebase（至少懂）
    

### 到什么程度算“过关”

- 你能写一个 `drivers/` `bsp/` `app/` 的固件项目结构
    
- UART 接收稳定：不丢包、不阻塞（有 ring buffer）
    
- 每个模块都有清晰接口（`.h` 不乱暴露变量）
    

### 小项目（寒假前就能做出）

**P0-雏形：STM32 采集数据 → 串口发给电脑 → 电脑发 MQTT 上云**

- STM32：读一个传感器（比如温湿度/IMU都行）
    
- 电脑：Python 脚本读取串口，发布 MQTT
    
- 云端：Docker 起一个 Mosquitto/EMQX，本地也算“云”（先跑通闭环）
    

> 这个雏形非常重要：它让你从“学课程”变成“做系统”。

---

# 1）大二下：完成 P0（第一个真正作品集）

**目标：做出一个能写进简历、能现场演示的端到云系统**

### 学什么（顺序很关键）

1. **网络 & MQTT（面向项目）**
    

- MQTT QoS、Topic 设计、心跳、掉线重连
    
- 简单鉴权（账号密码/Token）
    
- 可选：TLS（加分项，不强求一口气啃透）
    

2. **后端最小栈（建议 Python FastAPI）**
    

- REST API：设备注册、查询设备状态、查询历史数据
    
- MQTT 消费：订阅设备上报消息 → 写入数据库
    
- 数据库：PostgreSQL（推荐）或 SQLite（也行）
    
- Docker Compose：一键启动 broker + 后端 + DB
    

3. **算法：稳定推进（不追数量，追模板）**
    

- 每周固定 5~8 题（两天一组专题）
    
- 专题顺序：数组/哈希 → 双指针 → 栈队列 → 二叉树 → BFS/DFS → 堆 → 动态规划入门
    

### P0 项目定义（你按这个做，简历会非常舒服）

**P0：IoT 设备数据平台（STM32端 + 网关/联网 + 云端服务）**

你有两种实现路径（都可，按现实硬件选）：

- **路径A（推荐，最像真实IoT）**：STM32 + ESP32（UART）联网  
    STM32 负责传感器/控制；ESP32 负责 WiFi + MQTT
    
- **路径B（成本最低）**：STM32 → 串口 → PC网关 → MQTT  
    先把“系统闭环”跑通，再逐步替换 PC 网关为 ESP32
    

#### P0 必做功能（这些就是面试官爱问的）

- 设备上报：周期上报 + 事件上报
    
- 掉线重连：断网恢复后自动续传/恢复心跳
    
- 设备状态机：INIT / CONNECTING / ONLINE / OFFLINE / ERROR
    
- 云端存储：按设备ID、时间写入
    
- 可视化：一个简单 Web 页面或 Grafana（哪怕只有曲线+在线状态）
    

#### P0 加分功能（选 1~2 个做）

- OTA（可以先做“参数热更新”版本）
    
- TLS 或 token 鉴权
    
- 异常告警：比如温度超阈值推送
    

### 过关标准（你做到这些就能投实习）

- GitHub 仓库 README 有：架构图、部署步骤、Demo动图/视频、接口文档
    
- 你能用 3 分钟讲清楚：为什么用 MQTT、QoS怎么选、掉线怎么办、消息如何落库
    

---


# 2）大二暑假：P0 打磨 + 面试基础 + 英语过四级（关键窗口）

**目标：把“做出来”升级成“很像工程师的作品”**

### 主要任务

1. P0 工程化打磨（很值）
    

- 日志分级、错误码规范、重试退避（指数退避）
    
- 写一个 `docs/`：协议说明、topic规范、数据格式
    
- GitHub Actions：自动 lint/build（哪怕只跑后端也行）
    

2. 面试准备（开始进入“可面试状态”）
    

- 算法：保持手感（每周 10~15 题，重在总结套路）
    
- OS/计网：做自己的“面试卡片”（每个问题3分钟回答）
    

3. 英语（你要海外，就必须现在开始吃红利）
    

- 目标1：**这段时间把 CET-4 拿下**（它是“基本门槛”）
    
- 目标2：每天 30 分钟技术英语输入（看/听） + 10 分钟复述输出  
    复述你自己的项目，是最高性价比（还能练面试表达）
    

---


# 3）大三上：做 P1（智能小车 or 机械臂）+ 决定主战位版本简历

**目标：第二个硬项目，让你像“能进组干活的人”**

### 学什么（更偏工程）

- **FreeRTOS（建议学）**：任务/队列/互斥/事件组（你做机器人类很有用）
    
- **C++ 工程化**：接口抽象、RAII、STL（不追模板黑魔法）
    
- **控制基础**：PID、滤波（互补滤波/简单卡尔曼了解即可）
    
- **基础安全意识（IoT加分）**：密钥/Token、固件校验（CRC/签名概念）
    

### P1 项目建议（你二选一）

#### 方案1：智能小车（推荐，展示面最广）

- STM32：电机PWM、编码器、PID闭环控制
    
- 传感器：IMU/超声/红外（看你玩法）
    
- 联网：复用 P0 的 MQTT 通道
    
- 云端：加“控制指令下发 + ACK确认 + 状态上报”
    
- 演示：网页/小程序实时看速度、里程、在线状态，支持远程下发“速度/模式”
    

#### 方案2：机械臂（更硬核，适合讲控制/运动学）

- STM32：舵机控制、动作序列、限位保护
    
- 上位机：简单GUI或Web发动作指令
    
- 云端：动作日志/任务队列/回放
    

> 你倾向互联网大厂（A优先），**智能小车更容易讲“系统、稳定性、协议、工程化”**；机械臂更偏硬件厂/机器人公司风格。  
> 但两者都可以端云闭环，你选你更愿意持续打磨的那个。

### 大三上结束你要做的关键事

- 做 **两份简历版本**（同项目，不同侧重点）：
    
    - **嵌入式版**：突出 RTOS/驱动/调试/性能/可靠性
        
    - **IoT后端版**：突出 MQTT/数据链路/存储/部署/可观测
        

---


# 4）大三下：实习投递期（把时间花在“拿offer”上）

**目标：投递—面试—复盘迭代，项目只做“锦上添花”**

### 主任务

- 算法：保持中等强度（每周 8~12 题，重点复盘）
    
- OS/网络：每天 30~45 分钟“面试卡片复述”
    
- 项目：只做“加分小迭代”
    
    - 比如：P0 增加鉴权 / P1 增加远程控制可靠性 / 增加监控告警
        

### 你要刻意训练的能力（决定你能不能进大厂）

- **把复杂系统讲清楚**：架构图 + 数据流 + 异常流
    
- **讲权衡**：为什么不用HTTP长轮询？为什么QoS选1不是2？为什么这样分topic？
    
- **讲排障**：你遇到过什么线上/联调问题，怎么定位解决
    

---


# 5）大四上：秋招/海外准备

- 国内：系统设计思维 + 项目深挖 + 面试强度提升
    
- 海外：英语表达 + GitHub 英文文档 + 可能需要考试（如雅思/托福）与项目叙事  
    你现在英语基础弱，所以海外是“中长期”，但完全来得及：**从现在开始每天持续积累**。
    

---

## 四、你每天/每周怎么安排（防止“想法多但落不下去”）

你时间很充裕，我给你一个**可长期执行的周模板**（你可按强度上下浮动）：

### 每周固定结构（建议）

- **主线项目（P0/P1）**：每周 12~18 小时
    
- **算法**：每周 6~8 小时
    
- **OS/计网/基础**：每周 4~6 小时
    
- **英语**：每周 4~5 小时（每天40~50分钟即可）
    
- **副业/个人IP（L3）**：每周 ≤ 3 小时（时间盒）
    

### 每天最稳的节奏（给你一个“不会崩”的日程骨架）

- 2h：主线项目（写代码/调试）
    
- 1h：算法（1~2题 + 复盘）
    
- 45min：OS/计网（看一节/做一页卡片）
    
- 40min：英语（听/读 + 复述）
    
- 10min：记录（Obsidian：今天做了什么/卡点/明天第一件事）
    

**周末休息一天半**完全OK：  
留半天做“整理 + 复盘 + 发博客/视频”，别在周末搞重活。

---


## 五、你外卖小程序“卡死”的解法（不让它拖垮主线，还能变加分项）

你现在的问题本质不是“不会写代码”，而是：

> **接口契约不清 + 角色/权限/多租户模型不稳定 + 前后端联调缺少“可验证的中间层”**  
> 再叠加“主要靠AI写”，就会出现：功能看似很多，但一对接就炸。

我给你一个“工程上最稳的解耦方案”，按顺序做，你会明显解卡。

### 1）先把“系统边界”写成一页纸（1小时就够）

明确四类角色与数据域：

- 用户端（下单）
    
- 商户端（接单/出餐）
    
- 骑手端（配送）
    
- 管理员Web（多商户管理/审核/结算/运营配置）
    

所有数据都要带：`tenant_id(商户/门店)` 或者用 `merchant_id/store_id` 做多租户隔离。

### 2）接口优先：用 OpenAPI/Swagger 定契约（你现在最缺的）

你要做到：  
**前端不需要等后端写完也能联调**，后端不需要猜前端要什么字段。

做法：

- 先把管理员后台最关键的 10~20 个接口列出来（不要全做）
    
- 写 OpenAPI 文档（哪怕手写 YAML/JSON 也行）
    
- 用工具生成前端请求代码（减少“对接误差”）
    

### 3）引入“BFF/网关层”（可选但很救命）

因为你是多端（小程序多角色 + Web），很容易出现“为了某个端改接口，另一个端全坏”。

解决：

- 后端保持稳定的“领域接口”（订单、商户、骑手、结算…）
    
- 每个端有一个轻量 BFF 层（或至少在后端按 role 分 controller），避免互相污染
    

### 4）用“接口用例”驱动联调（不用猜）

你做一个 `postman/` 目录或 `tests/`：

- 每个接口至少 1 个成功用例 + 1 个失败用例（权限/参数不合法）
    
- 这样 AI 写代码也不怕：**用例过了才算完成**
    

### 5）上线策略：只做 MVP，不要试图一次“全功能”

如果你要赚钱上线，建议你先把闭环压到最小：

- 管理员：商户入驻/门店配置/菜品管理/订单监控（先别做复杂结算）
    
- 商户：接单/出餐状态
    
- 骑手：接单/送达
    
- 用户：下单（支付如果一时搞不定，就先用“线下支付/到店付”跑通运营）
    

> 这个项目你不要丢，它对你投后端非常加分：  
> 多租户、RBAC、订单状态机、异步通知、可靠性——都是面试官爱问的。

但记住：**它只能是 L3 或 L2，不能抢 P0/P1 的时间。**

---

## 六、英语路线（结合你“海外目标”但不内耗）

你现在四级未过，策略是：

1. **短期目标（6个月内）**：过四级
    
2. **中期目标（大三结束）**：能用英语完整讲你的 P0/P1（哪怕磕巴也行）
    
3. **长期目标（毕业前）**：根据国家准备雅思/托福或其它路径（你到大三再决定也不晚）
    

每天固定动作（最有效）：

- 15min：精听（技术视频/英语播客）
    
- 15min：跟读复述（复述你今天做的项目内容）
    
- 10min：把一个项目段落写成英文 README（每周写一点，半年就很强）
    

---


## 七、你从下周开始立刻执行的“7天启动清单”

（你照这个做，迷茫会明显下降）

1. 建一个 GitHub Monorepo：`iot-end2cloud/`（或分仓也行）
    
2. 定 P0 的最小闭环：STM32采集 → MQTT → DB → 页面/曲线
    
3. STM32 先完成：UART稳定发送 + 传感器读取（别贪多）
    
4. Docker 起 broker + DB（本地跑起来就是胜利）
    
5. Python 写最小后端：订阅 MQTT → 写入 DB
    
6. 写一个 README（哪怕只有 10 行）：你的架构图 + 运行步骤
    
7. Obsidian 建一个“每周复盘模板”：本周产出/卡点/下周第一件事

---

下面我直接给你一个「执行版」：**P0/P1 技术选型 + 仓库结构 + 16周里程碑（按周拆）+ 你的外卖小程序如何用工程方法解卡（且不拖主线）+ 英语与内容输出怎么绑定主线**。

---

# 1) 你的最优定位（按你A > C > B的排序来定）

你要拿国内互联网大厂实习，最稳的简历画像是：

- **主战位：嵌入式/端侧（A）**
    
    - 你正在学 STM32 + OS，顺势最强
        
    - 做出端侧工程化能力（状态机、驱动、RTOS/中断、调试、稳定性）
        
- **副战位：IoT后端/平台（B）**
    
    - 用“端到云闭环项目”自然覆盖：MQTT、设备管理、落库、Docker部署、可视化
        
- **海外（C）**：从今天开始“持续复利”式推进（英语 + 英文README + 英语讲项目），不和主线抢时间，但不断档。
    

> 你不需要现在二选一“A或B”。  
> 你需要做一个项目，让你“同时能投A，也能投B”。

---

# 2) P0 项目：我给你定一个“能进简历、能演示、能扩展到P1”的端到云闭环

## P0 名称（建议你就这么写在简历上）

**“基于 STM32 + ESP32 的端到云 IoT 设备数据平台（MQTT + 设备状态机 + 指令下发 + 数据看板）”**

## 为什么一定要 STM32 + ESP32 组合？

- STM32F103 强项：外设、实时控制、驱动、可靠性（对A岗位加分）
    
- ESP32 强项：WiFi、TLS、MQTT、网络栈（让你快速跑通云端）
    
- 二者通过 UART 通信：这本身就是一个非常工程化的点（协议、重传、CRC、队列）
    

---

# 3) P0 技术选型（给你“默认最优解”，你照着做就行）

## 端侧（STM32F103）

- 语言：**C（主）**，后期可把部分模块换成 C++（加分但不急）
    
- 驱动：HAL（先快速落地），你有余力再逐步理解底层（LL/CMSIS）
    
- 必做模块：
    
    - `bsp/`：时钟、GPIO、UART、I2C/SPI、定时器
        
    - `drivers/`：传感器驱动（建议 I2C：SHT30/BME280/MPU6050 任一）
        
    - `app/`：状态机、数据采样、与ESP32的通信协议、日志/错误码
        

## 联网侧（ESP32）

- 推荐：**ESP-IDF**（比AT指令更像“工程项目”，也更能写进简历）
    
- ESP32要做的事：
    
    - WiFi连接与重连
        
    - MQTT连接（先不TLS也行，后面加）
        
    - 订阅指令Topic、发布数据Topic
        
    - 与STM32的UART协议：帧格式、CRC、ACK、重传、缓冲队列
        

## 云端（本地Docker先跑通，后期上云）

- MQTT Broker：**EMQX**（功能更全，面试也好聊）或 Mosquitto（更轻）
    
- 后端：**FastAPI（Python）**
    
    - 理由：你起点只有C，Python能最快把云端做出来
        
    - 后期如果你要更贴国内互联网大厂，也可以把部分重写为 Go（作为“进阶迭代”，不用一开始就上Go）
        
- DB：PostgreSQL（足够用、面试通用）
    
- 可视化：两条路你选其一
    
    1. **最轻前端**：FastAPI + 简单网页（ECharts）+ WebSocket实时展示
        
    2. **最快成品**：Grafana 读取DB（更像“工程交付”）
        

> 你的 Mac mini M4 跑 Docker 完全OK。尽量选多架构镜像（EMQX/Postgres一般都有）。

---

# 4) P0 的“协议与架构”——你要按这个设计，面试就有内容讲

## Topic 设计（强烈建议你直接用）

- 遥测上报：`iot/{device_id}/telemetry`
    
- 设备心跳：`iot/{device_id}/heartbeat`
    
- 云端下发指令：`iot/{device_id}/cmd`
    
- 设备ACK：`iot/{device_id}/ack`
    
- 设备日志（可选）：`iot/{device_id}/log`
    

## 消息格式（先用JSON，落地最快）

```json
{
  "device_id": "stm32-001",
  "ts": 1730000000,
  "seq": 1024,
  "metrics": {
    "temp": 24.6,
    "hum": 60.2
  },
  "status": "ONLINE"
}
```

## UART帧协议（STM32 ↔ ESP32，必做，极其加分）

建议你做“有帧头+长度+类型+序号+CRC”的二进制协议：

- `SOF(2B) + LEN(2B) + TYPE(1B) + SEQ(4B) + PAYLOAD + CRC16(2B)`
    
- TYPE例子：Telemetry / Cmd / Ack / Log
    
- STM32发Telemetry给ESP32，ESP32发ACK回来；失败重传N次后报错码
    

> 这套协议一做出来，你就不是“只会一点C”的学生了，你是“懂工程交付”的候选人。

---

# 5) 仓库结构（你按这个建，后面不会乱）

推荐 monorepo（一个仓库把端-云-文档都放齐）：

```
iot-end2cloud/
  firmware-stm32/
    Core/
    Drivers/
    app/
    bsp/
    drivers/
    protocol/
    README.md
  esp32-gateway/
    main/
    components/
    README.md
  cloud/
    docker-compose.yml
    backend/
      app/
      tests/
      README.md
    dashboard/   # 可选：简单前端
  docs/
    architecture.md
    topic-spec.md
    uart-protocol.md
    api-spec.md
    demo.md
  tools/
    scripts/
  .github/workflows/
```

**你的目标**：任何人 clone 仓库后，能：

- `docker compose up -d` 启动云端
    
- 烧录firmware/esp32后，看到数据上报和页面曲线
    
- README里有架构图 + 演示视频
    

---

# 6) 大二下 16 周执行计划（按周里程碑，照着做就行）

> 你时间很充裕，我按“每周 20~30小时有效学习/编码”来排。  
> 如果哪周考试多，就把该周目标砍半，但**顺序别乱**。

## Sprint 0（第1-2周）：把开发环境和工程骨架搭好

### Week 1

- 建仓库 + 写最简 README（先别等完美）
    
- STM32：
    
    - 创建工程结构（bsp/drivers/app/protocol）
        
    - UART收发通（先轮询或中断都行）
        
- ESP32：
    
    - ESP-IDF 工程跑通（Hello + WiFi扫描）
        
- 输出：
    
    - 博客/笔记：`STM32工程结构与模块边界怎么划分`
        

### Week 2

- STM32：实现 **UART RX 环形缓冲**（中断接收 + ring buffer）
    
- 设计 UART 帧协议（写到 docs/uart-protocol.md）
    
- ESP32：WiFi连接 + 断线重连（日志可见）
    
- 输出：
    
    - 一个最小“串口协议帧收发”demo（STM32↔PC或STM32↔ESP32都行）
        

---

## Sprint 1（第3-5周）：端侧采集 + 网关MQTT上云（闭环雏形完成）

### Week 3

- STM32：接一个传感器（建议 BME280 或 SHT30）
    
- 把数据封装成你的 UART 帧 `Telemetry`
    
- ESP32：UART协议解析（至少能把payload打印出来）
    

### Week 4

- ESP32：MQTT连接 + 发布 `telemetry` topic
    
- 云端：docker compose 起 EMQX（或Mosquitto），用 MQTTX/命令行验证收到消息
    
- 输出：
    
    - 录一个10秒视频：终端里能看到 MQTT 收到数据
        

### Week 5

- STM32：加状态机（INIT/ONLINE/ERROR）
    
- ESP32：实现 ACK（STM32发一次，ESP32回ACK；STM32超时重传）
    
- 云端：写一个最小 Python consumer（订阅topic，打印并写入简单文件/SQLite）
    
- 输出：
    
    - docs/topic-spec.md（topic规范）
        
    - 博客：`掉线/重传/ACK：为什么你的IoT系统不能只靠“发出去就算了”`
        

---

## Sprint 2（第6-9周）：云端“像样起来”（落库 + API + 查询）

### Week 6

- 云端：PostgreSQL 接入
    
- 建表：devices、telemetry（含ts、seq、metrics）
    
- Consumer：订阅MQTT → 落库
    
- 输出：`cloud/backend` 能跑通一条数据链路
    

### Week 7

- FastAPI：设备注册/查询设备列表/查询某设备最近N条数据
    
- 写 api-spec.md（哪怕是手写接口列表也行）
    
- 输出：Postman/HTTPie 能调通
    

### Week 8

- 加“指令下发”链路：
    
    - 云端API `POST /devices/{id}/cmd` → 发布 MQTT cmd
        
    - ESP32订阅cmd → 转发UART给STM32
        
    - STM32执行后回ACK（通过ESP32 → MQTT ack）
        
- 输出：**端云双向**闭环完成（这是简历重点）
    

### Week 9

- 可靠性补齐：
    
    - ESP32 MQTT断线重连 + 指令ACK超时处理
        
    - STM32执行失败错误码定义
        
- 输出：写一份 `demo.md`：演示步骤（面试时你照着演示）
    

---

## Sprint 3（第10-12周）：可视化 + 工程化（让它像“能交付的系统”）

### Week 10

- 可视化二选一：
    
    - 简单网页（ECharts）显示曲线 + 在线状态
        
    - 或 Grafana 看板（更快）
        
- 输出：截图/短视频加入 README
    

### Week 11

- 加鉴权（选最简单但有效的）：
    
    - 每台设备一个 `device_secret`
        
    - 上报payload加 HMAC 或 token
        
- 云端校验，不通过直接拒绝落库
    
- 输出：安全加分项（非常对国内大厂“工程意识”口味）
    

### Week 12

- CI：GitHub Actions（后端跑 lint + 单元测试；固件至少跑格式检查/构建脚本）
    
- 输出：`.github/workflows` + badges
    

---

## Sprint 4（第13-16周）：打磨成作品集 + 启动P1选型

### Week 13

- 写“项目一页纸设计文档”（架构图、数据流、异常流、选型理由、取舍）
    
- 输出：`docs/architecture.md`（这就是你面试时的“讲稿”）
    

### Week 14

- 压测/边界测试（不用很复杂，但要“有意识”）：
    
    - MQTT消息频率提高到 X Hz 是否丢包？
        
    - ESP32断网 30 秒恢复是否自动续连？
        
- 输出：`docs/perf-and-reliability.md`
    

### Week 15

- 录 Demo 视频（3~5分钟）：
    
    1. 系统架构图
        
    2. 实时数据曲线
        
    3. 云端下发指令控制端侧（必须演示）
        
- 输出：视频链接放 README + Quartz 项目页
    

### Week 16

- P1 启动准备（不做重活，只做选型和采购）
    
- 选智能小车/机械臂路线（我建议你先小车）
    
- 输出：`docs/p1-plan.md`（采购清单、里程碑、风险）
    

---

# 7) 你该买哪些硬件（≤2000预算，按“最划算”给你列清单）

**优先级1（立刻买，直接提升成功率）**

- ESP32 DevKit（1块够）
    
- ST-Link（如果你没有稳定调试器）
    
- 逻辑分析仪（非常建议，几十到一百多那种就能救命：抓UART/I2C/SPI）
    
- 传感器模块：BME280 或 SHT30（再加一个 MPU6050 做扩展）
    

**优先级2（做P1小车才买）**

- 小车底盘套件（电机+轮子+车架）
    
- 电机驱动（TB6612 / DRV8833）
    
- 编码器（有编码器的小电机更好讲“闭环控制”）
    
- 电池+充电模块
    

> 你预算很充足，买一套“能调试的装备”比买一堆传感器更值钱。

---

# 8) 你的外卖小程序（云开发）怎么解卡：一套“工程化解耦打法”，且不拖主线

你现在卡点：**管理员Web后台与小程序端对接问题、功能缺失、耦合混乱、AI写代码导致你无法掌控**。

我给你一个“最快解卡、最少返工”的方案：**API契约优先 + 状态机优先 + 权限优先**。

## 8.1 先用 2 小时把“系统骨架”定死（你现在最大的问题是骨架没定）

把外卖系统拆成4个域（域 = 你后端代码的模块）：

1. 商户域（merchant/store/product）
    
2. 订单域（order + order_items + 状态机）
    
3. 骑手域（rider + dispatch）
    
4. 管理域（audit/config/ops）
    

**规则**：所有端（用户/商户/骑手/管理员Web）都只能调用 API，不能直接读写数据库集合。  
否则耦合永远解不开。

## 8.2 用“订单状态机”解决一半对接问题（这就是你卡死的本质）

把订单状态定成枚举并写清楚允许的流转：

- CREATED（已创建未支付）
    
- PAID（已支付待接单）
    
- ACCEPTED（商户已接单）
    
- PREPARING（制作中）
    
- READY（待骑手取餐）
    
- PICKED_UP（骑手已取）
    
- DELIVERED（已送达）
    
- CANCELED（取消）
    
- REFUNDED（退款）
    

然后每一个状态变更都由云函数统一处理（校验权限、校验当前状态、写入日志）。

这样：

- 小程序端不需要猜后端“应该是什么状态”
    
- 管理员端也不需要“硬改数据”
    
- AI写代码也不会把状态写崩
    

## 8.3 解决“管理员Web与小程序耦合”的关键：接口契约（Contract）+ Mock

你马上做这三件事（按顺序）：

1. 写一个 `api-spec.md`（哪怕不是OpenAPI，先把接口列出来）
    
    - 管理员最关键的10个接口：商户审核、门店管理、订单查询、退款、骑手管理等
        
2. 给每个接口写一份“请求/响应示例JSON”
    
3. 做 Mock（最简单：云函数返回固定假数据），让前端先对接跑通
    

> 你一旦有契约，AI写代码就从“瞎写”变成“按契约补全”。

## 8.4 你要把副业项目降级成“每周2~3小时维护”

- 这项目要赚钱可以，但不要在学期内重构成大型系统
    
- 目标：先上线 MVP 跑起来（能下单、商户接单、骑手送达、管理员能看见关键数据）
    

---

# 9) 英语与海外目标：你现在最聪明的做法

你不用现在就焦虑澳洲/德国/美国的差异，你现在要做的是：

- **6个月内：过四级（硬门槛）**
    
- **每天40分钟**（固定，不要时长内耗）：
    
    - 15min 技术英语输入（看/听）
        
    - 15min 复述：用英语讲你今天P0做了啥（对面试最有效）
        
    - 10min 写：每周给P0 README 加一段英文（半年后你英文项目文档会非常像样）
        

---

# 10) 你下周就能开干的“第一周任务清单”（最小可执行）

1. 买 ESP32 + 传感器 +（强烈建议）逻辑分析仪
    
2. 建仓库 `iot-end2cloud`，按我给的结构建目录
    
3. STM32：UART RX ring buffer 写出来（中断接收）
    
4. docs/ 里写：UART帧协议草案 + topic规范草案
    
5. ESP32：ESP-IDF 跑通 WiFi 连接日志
    
6. 写一篇 Quartz：`我如何设计STM32↔ESP32通信协议（第一版）`
    

---

# 0）先给你一个结论（省你内耗）

1. 你发的 OpenOCD 配置里 `source [find interface/cmsis-dap.cfg]` 说明你现在**本质是在用 CMSIS‑DAP 探针**（你那个白色“ARM JTAG”盒子就很像）。
    
2. 你这块普中板（从照片上能看到 `www.prechin.cn` 和 “USB1 DOWNLOAD / USB2 MCU”）**通常不带板载 ST‑LINK**：
    
    - `USB1 DOWNLOAD` 多数是 **串口下载/USB转串口**（给 Bootloader/串口通信用）
        
    - `USB2 MCU` 可能是 **直连 MCU 的 USB 设备口**  
        这两个口**都不是 ST‑LINK**，所以你“用正常 stlink 不行”的感觉很常见（其实是“接口不是那回事”）。
        
3. 你能在 CubeIDE 跑通，说明：**探针 + 连线 + 芯片 + OpenOCD/ GDB 这条链路至少有一条可用路径**。  
    VS Code 失败，最常见原因：
    
    - VS Code 调试时用的不是 CubeIDE 那套 openocd/gdb
        
    - 或者 VS Code 插件强行用 ST‑LINK/st-util
        
    - 或 openocd scripts 路径没配到（`find interface/...` 找不到）
        
    - 或调试频率太高、reset/halt 流程不一致
        

---

# 1）10 分钟“止血排障”：把问题定位到是哪一层

> 你现在最需要的是：**先确认“命令行能不能 debug”**。命令行能 = VS Code 只是配置问题；命令行不能 = 才考虑硬件/连线/权限。

## Step A：先把 CubeIDE 全部退出、拔插探针

CubeIDE 如果还占着 CMSIS‑DAP，VS Code/OpenOCD 会抢不到设备。

## Step B：在终端里单独启动 OpenOCD（用你 CubeIDE 生成的 cfg）

假设你把这段 cfg 存成 `debug/openocd.cfg`（建议你就这么做，别只放在 IDE 里）：

```bash
openocd -f debug/openocd.cfg -d2
```

你期待看到类似信息（不同版本略有差异）：

- 识别到 CMSIS‑DAP / DAPLink
    
- 找到 `stm32f1x` target
    
- 监听 `3333` 端口
    

如果这里就报错：

- `Can't find interface/cmsis-dap.cfg`：是 **scripts 路径问题**
    
- `unable to open CMSIS-DAP device`：是 **设备占用/权限/线没连好/频率太高**
    

## Step C：再开一个终端，用 GDB 连接

```bash
arm-none-eabi-gdb build/你的工程.elf
(gdb) target extended-remote :3333
(gdb) monitor reset halt
(gdb) load
(gdb) continue
```

- 这里如果能 `load` 并跑起来：恭喜，**硬件完全没问题**，VS Code 只是“launch.json 配置问题”
    
- 如果 `monitor reset halt` 卡住：多半是 reset 配置/NRST 没接/你的程序禁了 SWD（下面我会讲）
    

---

# 2）你现在最稳的“现代化 VS Code 方案”（推荐你走这条）

很多同学以为“现代化=装 STM32 官方插件”，但实际上最稳、最通用的是：

✅ **CubeMX 生成工程 + VS Code 写代码/编译 + Cortex‑Debug 调试（OpenOCD/pyOCD）**

> 你用 CMSIS‑DAP 的话，**Cortex‑Debug**几乎是最省心的。

---

## 2.1 你需要的 VS Code 插件（最少集）

- C/C++（微软那个）
    
- **Cortex-Debug**（关键）
    
- 如果你用 CMake：CMake Tools（可选但推荐）
    
- 如果你用 Makefile：不强制
    

> 你可以不用“STM32 的插件”也能有现代化体验：代码跳转、编译、烧录、断点、变量观察全都有。

---

## 2.2 关键点：让 VS Code 用“CubeIDE 那套 openocd/gdb”（避免版本不一致）

你 CubeIDE 能跑通，说明它自带的 openocd/gdb 是能用的。  
所以 VS Code 最稳的做法是：**直接指定 serverpath / gdbPath 指向 CubeIDE 内置工具**。

### 在 Mac 上找 CubeIDE 的 openocd/gdb 路径（你照抄执行）

```bash
# 找 openocd
find /Applications/STM32CubeIDE.app -name openocd -type f 2>/dev/null | head

# 找 gdb
find /Applications/STM32CubeIDE.app -name arm-none-eabi-gdb -type f 2>/dev/null | head
```

你会得到类似路径（每个人版本号不一样）：

- `.../tools/bin/openocd`
    
- `.../tools/bin/arm-none-eabi-gdb`
    

把它们复制出来，填进 VS Code 的 launch.json。

---

## 2.3 一个可直接用的 `.vscode/launch.json`（CMSIS‑DAP + OpenOCD）

把你 CubeIDE 生成的 cfg 放到工程里，比如：`debug/openocd.cfg`

```jsonc
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "STM32F103 (CMSIS-DAP, OpenOCD)",
      "type": "cortex-debug",
      "request": "launch",
      "servertype": "openocd",

      // 1) 指向 CubeIDE 自带 openocd（用 find 找到的那个）
      "serverpath": "/Applications/STM32CubeIDE.app/Contents/Eclipse/plugins/你机器上的路径/tools/bin/openocd",

      // 2) 指向 arm-none-eabi-gdb
      "gdbPath": "/Applications/STM32CubeIDE.app/Contents/Eclipse/plugins/你机器上的路径/tools/bin/arm-none-eabi-gdb",

      // 3) 你的 ELF 路径（按你实际 build 输出修改）
      "executable": "${workspaceFolder}/build/your_project.elf",
      "cwd": "${workspaceFolder}",

      // 4) 直接用你这份 cfg（里面 already include interface/target）
      "configFiles": [
        "${workspaceFolder}/debug/openocd.cfg"
      ],

      // 5) 可选：如果你发现 8MHz 不稳定，先把速度降下来
      "openOCDLaunchCommands": [
        "adapter speed 1000"
      ],

      "runToMain": true,
      "postRestartCommands": [
        "monitor reset halt"
      ]
    }
  ]
}
```

> 你现在 cfg 里 `set CLOCK_FREQ 8000` 可能在某些 OpenOCD 组合里不生效，或者对某些线材/板子太激进。  
> **我建议你先用 1000~2000 kHz 确保稳定，稳定后再往上加。**

---

## 2.4 一个建议版 `debug/openocd.cfg`（更“通用稳”）

你现在那份 cfg 可以继续用。我给你一份更通用的写法，你可以对比：

```tcl
source [find interface/cmsis-dap.cfg]
transport select swd

# 稳定优先：先低速，跑通后再升
adapter speed 1000

set CHIPNAME stm32f1x
source [find target/stm32f1x.cfg]

# 如果你没有接 NRST，先用 none
reset_config none
```

---

# 3）你现在这种“能在 CubeIDE 跑、VS Code 跑不了”最常见 4 个坑（对照查）

## 坑1：VS Code 用了“别的 OpenOCD”，找不到 scripts

症状：

- 报 `Can't find interface/cmsis-dap.cfg` 或 `target/stm32f1x.cfg`
    

解决：

- 用我上面的方法指定 `serverpath` 指向 CubeIDE 的 openocd
    
- 或在 Cortex‑Debug 里加 `searchDir`（如果你坚持用别的 openocd）
    

---

## 坑2：你的 VS Code 插件默认走 ST‑LINK，但你实际是 CMSIS‑DAP

症状：

- 它找 ST‑LINK 找不到、或者 st-util 报错
    

解决：

- **不要纠结“STM32 插件”**，直接用 **Cortex‑Debug + OpenOCD/pyOCD**
    
- 或者换一只明确可用的 ST‑LINK/V3（但你现在已经有可用探针，不必急）
    

---

## 坑3：调试频率/线材/供电导致“偶发连不上”

症状：

- 有时连上有时连不上、或者下载时失败
    

解决：

- `adapter speed 1000` 起步
    
- 确保 GND 线牢靠、线尽量短
    
- 供电稳定（你板子 USB/外接供电别飘）
    

---

## 坑4：你的程序把 SWD/JTAG 关掉了，导致“烧进去以后再也连不上”

STM32F1 很多同学会改 AFIO remap 或者误操作把 PA13/PA14 当普通 GPIO，甚至禁用 SWD。

解决：

- 先确保你程序里**没有**禁用 SWD
    
- 真遇到“跑了程序后断点再也进不去”，用：
    
    - **connect under reset**（你 cfg 里提到的思路）
        
    - 或上电按住复位键，OpenOCD 连接成功后再松手
        
- 最后兜底：用串口 Bootloader 重新刷回“安全固件”
    

---

# 4）你已确定：P1 做智能小车 + 云端 Python→Go。给你 P1 执行版（12 周）

> 注意：P1 的前提是你 P0（端到云闭环）已经跑通或至少雏形跑通。  
> P1 是“加分硬项目”，但不能反过来拖垮你打底。

## 4.1 P1 系统架构（面试官最爱听的那种）

- STM32：运动控制（PWM/编码器/PID/状态机）
    
- ESP32：联网网关（WiFi + MQTT + 指令下发/ACK + 日志）
    
- 云端：复用 P0 平台（设备管理 + 指令 API + 数据看板）
    
- 可选（后期加分）：上位机/树莓派跑视觉（不是必须）
    

## 4.2 硬件清单（优先买“能闭环”的）

- 车架 + 2/4 电机（**尽量买带编码器的**）
    
- 电机驱动：TB6612 / DRV8833
    
- 供电：电池 + 稳压模块（5V/3.3V）
    
- 传感器：IMU（MPU6050/ICM系列）、超声/红外循迹（二选一）
    
- **ESP32 DevKit**
    
- （强烈建议）小逻辑分析仪：调 UART/I2C/SPI 很救命
    

## 4.3 12 周里程碑（你照着排周计划就不迷茫）

- Week 1：电机 PWM 控制跑通（开环）
    
- Week 2：编码器采集跑通（计数/测速）
    
- Week 3：PID 速度环稳定（给定速度→能稳住）
    
- Week 4：基本里程计/方向控制（直线、转向）
    
- Week 5：STM32↔ESP32 UART 协议复用（SOF/LEN/CRC/ACK）
    
- Week 6：MQTT 上云：遥测上报（速度、电量、状态）
    
- Week 7：云端下发控制指令（速度/模式）+ ACK 闭环
    
- Week 8：避障/循迹（二选一）+ 状态机完善
    
- Week 9：Dashboard（实时曲线 + 在线状态 + 控制按钮）
    
- Week 10：可靠性：断网重连、指令幂等、重试退避
    
- Week 11：写文档 + Demo 视频（3~5 分钟）
    
- Week 12：加分迭代：参数热更新 / OTA / 简单异常告警（二选一）
    

---

# 5）简历两版（你可以直接套模板写）

## 5.1 嵌入式/端侧版（A岗重点）

- 使用 STM32F103 实现电机控制与传感器采集，完成 PWM/编码器/中断/定时器驱动与模块化封装（bsp/drivers/app 分层）
    
- 设计 STM32↔ESP32 二进制通信协议（SOF/LEN/SEQ/CRC/ACK/重传），实现掉线重连与错误码体系，提升端侧通信可靠性
    
- 实现运动控制闭环（PID 速度环/里程计），通过日志与抓包定位并解决抖动/丢包等联调问题（可写你真实踩坑）
    

## 5.2 IoT后端/平台版（B岗重点）

- 搭建 EMQX + FastAPI + PostgreSQL 的 IoT 数据链路，实现设备遥测落库、历史查询与指令下发 API，并制定 topic 规范与消息格式
    
- 基于 Docker Compose 实现一键部署与复现，加入 CI（lint/test/build），提升交付效率与可维护性
    
- 实现指令下发 ACK 机制与幂等处理，保障弱网情况下控制指令可达与状态一致性（写清你怎么做的）
    

> 你可以把同一个项目写成两种风格，这就是“端到云候选人”的优势。

---

# 6）你的 Obsidian → Quartz → 短视频：最低成本复用模板

你每周固定产出 1 篇“项目周报”就够了，然后拆成视频脚本：

**博客结构（固定 5 段）**

1. 本周目标（1句话）
    
2. 实现了什么（3条）
    
3. 最大卡点（1条）
    
4. 我怎么定位/解决（步骤）
    
5. 下周计划（2条）
    

**短视频脚本（60秒三段式）**

- 5秒：钩子（“我调了3天 STM32 VS Code 调试，原来问题在这一步”）
    
- 40秒：关键知识点 + 演示（OpenOCD + GDB 连接流程）
    
- 15秒：结尾复盘 + 下期预告（“下周我把 UART 协议做成 ACK/重传”）
