---
title: 实时规则：时序/并发/阻塞（MCU/网关/云端）
draft: false
stage: budding
---

# 实时规则（Real-time Rules）

这页的目标是把“会把系统拖死”的底层约束钉死成规则：**中断/主循环/线程/队列/超时/重试/背压**怎么定，避免你 P0/P1 越做越卡、越改越脆。

> 协议/Topic/API/DB 的单一真相在 [[P0_SPEC_v1]]；日志字段与链路追踪在 [[日志规范]]；故障注入与验收在 [[测试体系]]。

---

## 0）总原则（跨端通用）

- **把阻塞点变成可观测事件**：每个“等待”都要有超时、重试次数、错误码与日志。
- **把偶发问题变成可复现问题**：要么有脚本复现，要么有故障注入复现（见 [[测试体系]]）。
- **同一条命令全链路只用一个幂等键**：`cmd_id`（见 [[P0_SPEC_v1]]），所有日志/ACK/DB 都能用它串起来。
- **一条链路只允许一个地方做重试**：默认由网关做“串口等待 ACK 的重试”，后端只做“状态超时标记”，避免“双重重试导致风暴”。

---

## 1）设备端（STM32）实时规则

### 1.1 中断（ISR）规则（必须）

- ISR 只做：**读寄存器/缓存一个字节 → 写入 ring buffer → 置位标志/计数**。
- ISR 禁止做：
  - CRC/解帧/命令执行
  - `printf`/阻塞 UART 发送
  - I2C/SPI 访问（除非你非常确定且有严格时序预算）
  - 动态内存分配（`malloc/free`）

### 1.2 主循环/任务规则（必须）

- 解析器（parser）运行在主循环/任务上下文：**从 ring buffer 拉字节 → 状态机组帧 → CRC 校验 → 分发处理**。
- 每次解析失败（BAD_CRC/BAD_LEN）：至少消费 1 字节并继续搜 SOF，确保 forward progress（见 [[P0_SPEC_v1]] 的 resync 规则）。
- 命令执行要有**最坏耗时预算**：单次执行超过阈值就拆分为状态机（例如分阶段执行）或下放到低优先级任务。

### 1.3 Buffer 容量估算（经验够用版）

你不需要精确到字节，但必须“有一套能解释的估算方法”：

- UART 115200：约 `11.5KB/s`（10bit/byte 粗估）
- 目标：主循环即使被阻塞 `100ms` 也不丢数据 → 需要缓存 `~1150 bytes`
- 建议：RX ring buffer **至少 2048B**（更稳 4096B）

> 当你改了遥测频率/帧长度，先重新估算缓存与 CPU 负载，再谈“优化”。

### 1.4 二进制协议与日志（强制分离）

- 串口链路只传 **P0 二进制帧**（TELEMETRY/CMD/ACK/LOG）。
- 人类可读日志要么：
  - 用 `LOG` 帧承载（仍然是二进制帧），要么
  - 另开调试口（例如 SWO/另一路 UART），不允许把 `printf` 混进数据流。

---

## 2）网关（Python）并发/阻塞规则

### 2.1 线程模型（推荐最小复杂度）

建议固定三块职责（线程/任务），避免“哪里都能读写串口”：

- 串口读线程：只负责 `read → decode → push(queue)`
- MQTT 线程/回调：只负责 `subscribe cmd → push(queue)`、`publish telemetry/ack`
- 主协调线程：拉取队列，做“cmd 下发 + 等 ACK + 重试/超时”，并写统一日志

### 2.2 串口写入规则（避免死锁）

- 串口写入只允许 **一个线程** 执行（主协调线程），否则必然出现“交错写/帧粘连/ACK 对不上”。
- 等待 ACK 必须有：
  - 超时（默认 1s）
  - 重试次数（默认 2）
  - 失败时的“证据留存”（日志 + 原始字节 dump 的路径）

### 2.3 背压（Backpressure）与降级（P0 的默认策略）

当后端/DB 变慢时，网关会遇到“遥测堆积”：

- 默认策略（P0 推荐）：**遥测可丢，命令不可丢**
  - telemetry 队列满：丢弃最旧/最不重要的 telemetry，并计数 + 打 WARN
  - cmd 队列满：拒绝新命令或阻塞接收（并告警），但不要静默丢命令

> 这条规则能让你在面试里解释：为什么系统不会因为“遥测洪峰”导致“命令失控”。

---

## 3）云端（后端/DB）阻塞规则

- MQTT ingest 不要阻塞 API：订阅回调里只做“解析/入队”，写库由 worker 执行（线程/协程均可）。
- 命令状态更新要保证一致性：
  - `cmd_id` 唯一
  - ACK 更新要么按事务更新，要么按“幂等更新”（重复 ACK 不改变最终结果）
- 把每个状态变化写进日志，并包含 `cmd_id/device_id`（见 [[日志规范]]）。

---

## 4）DoD（Definition of Done）：实时规则层面的“过关线”

下面这些达成，才算你真的把“时序/并发/阻塞”掌控住了：

- MCU：连续 30min 运行无死机；`BAD_CRC/BAD_LEN` 不会导致卡死；RX buffer 不溢出（或溢出可观测）
- 网关：串口拔插能恢复；断网 60s 能恢复；重启 broker 能恢复（见 [[测试体系]] 的故障注入清单）
- 全链路：一次命令能用 `cmd_id` 在三端日志中追踪（见 [[日志规范]]）

